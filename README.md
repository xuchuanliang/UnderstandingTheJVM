#《深入理解java虚拟机》
- java技术体系包括:java程序设计语言、各种硬件平台上的java虚拟机、class文件格式、java api类库、来自商业机构和开源社区的第三方java类库
- java程序设计语言+java虚拟机+java api类库称为jdk，是用于支持java程序最小的开发环境
- java api类库中的javaSE api子集和java虚拟机这两部分统称为JRE，JRE是支持javaSE程序运行的标准环境。
2019年8月15日 12:13:50 9/460
- 动态编译指的是在运行时编译，与之相对应的是事前编译，也叫静态编译
- JIT编译狭义来说是当某段代码即将被第一次执行时进行编译，因而叫及时编译，JIT编译是动态编译的一种特例，
- 自适应编译也是一种编译，但它通常执行时机比JIT编译迟，先让程序以某种方式运行起来，收集一些信息后再做动态编译
- 解释器是一条一条的解释执行源语言，比如php，javascript就是典型的解释性语言
- 编译器是把源代码整个翻译成目标代码，执行时不在需要编译器，直接在支持目标代码的平台上运行，这样执行效率比解释执行快很多。比如C语言代码被
编译成二进制代码（exe程序），在window平台上执行。

# 第二部分 自动内存管理机制
## Java内存区域与内存溢出异常
- java虚拟机运行期间管理的内存：程序计数器、java虚拟机栈、本地方法栈、方法区、堆
> 程序计数器(线程私有)：是一块很小的区域，可以看做是当前线程所执行的字节码的行号指示器，这块内存区域是线程私有

> java虚拟机栈(线程私有)：描述的是java方法执行的内存模型：每个方法在执行的时候都会创建一个栈帧用于存储局部变量、操作数栈、动态链接、方法出入口等信息，
每一个方法在调用直至执行完成的过程，对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。我们常说的java内存区分为栈内存和堆内存，这里说的栈内存
指的就是java虚拟机栈中的局部变量表部分，局部变量表存放了编译器可知的各种基本数据类型、对象引用类型（指向对象起始地址的引用指针）和
returnAddress类型（指向了一条字节码指令的地址），java虚拟机栈也是线程私有的

> 本地方法栈(线程私有)：与java虚拟机栈发挥的作用相似，只不过java虚拟机栈为虚拟机执行java方法，本地方法栈为虚拟机执行native方法（native方法是指在
java平台和本地C代码进行相互操作的API）

> java堆：java堆是java虚拟机管理内存中最大的一块，是线程共享的一块内存区域，在虚拟机启动时创建，用于存放对象实例，有时候叫GC堆，按照垃圾收集器
分代收集算法分为新生代和老年代，再细致分为Eden空间，From Survivor空间，To Survivor空间等；从内存分配角度线程共享的java堆中可能划分出
多个线程私有的分配缓冲区。

> 方法区：是各个线程共享的内存区域，用来存放被虚拟机加载的Class信息如类名、访问修饰符、常量、静态变量、即时编译器编译后的代码等数据。被称为永久代。
```java
package capter01;

/**
 * @author xuchuanliangbt
 * @title: Main
 * @projectName UnderstandingTheJVM
 * @description:
 * @date 2019/9/517:20
 * @Version
 */
public class Main {

    public static void main(String[] args){
        test1();
    }

    public static void test1(){
        /**
         * ==比较引用类型比较的是地址值是否相同
         * equals比较引用类型，默认也是比较地址值是否相同，而String类重写了equals方法，比较的是内容是否相同
         * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         * 创建字符串内存详解：
         * public static void main(String[] args){
         *     String a = new String("abc");
         * }
         * 1.首先main方法进栈;
         * 2.在栈中定义一个对象a，去堆中开辟一个内存空间，将内存空间的引用赋值给a，"abc"是常量，然后去字符串常量池查看是否有abc字符串对象，
         * 如果没有则在字符串常量池中分配一个空间存放abc，并将其地址空间存入堆中new出来的空间中
         * public static void main(String[] args){
         *     String a = "abc";
         * }
         * 1.首先main方法进栈
         * 2.在栈中定义一个对象a，去字符串常量池中查看是否存在值为abc的字符串对象，如果没有则在字符串常量池中分配一个空间存放abc，将abc的地址
         * 赋值为a
         * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         */
        /**
         * String对象中的intern()方法详解
         * 作用是查看常量池中是否存在和调用方法的字符串内容一样的字符串，如果有，则返回常量池中的字符串的地址；如果没有，就在常量池中写入
         * 一个堆中该字符串对象的引用，指向堆中的该对象，并返回该引用的地址
         *
         */
        /**
         * 1.虚拟机栈中开辟空间存放a
         * 2.堆中开辟空间存放一个String对象，并将该对象的地址存放在虚拟机栈的a中
         * 3.去字符串常量池查看是否已经存在abc字符串对象，如果不存在则在字符串常量池创建并将对象的地址存放在第二步堆内存创建的对象中
         * 下面的则虚拟机栈中a存放的指针和b存放的指针不同，都是堆内存中新创建的对象；两个堆内存中存放的内容是相同的，都是字符串abc在字符串常量池的地址
         */
        String a = new String("abc");
        String b = new String("abc");
        //true，都是字符串常量池中abc字符串的地址
        System.out.println(a.intern()==b.intern());
        //false 字符串常量池中abc字符串地址！=堆内存创建b时开辟的空间地址
        System.out.println(a.intern()==b);
        //false
        System.out.println(a==b.intern());
        /*
         * intern方法会到常量池中查找是否存在该对象，如果存在，返回该对象。不存在的话就创建该对象并返回该对象(jdk1.6),(jdk1.7)
         * 会在常量池中存一个指向堆中的那个对象的引用。 不存在往往是String s3 = new String("1") + new
         * String("1");这种形式，会在堆中有一个s3指向的11的对象和常量池中的1对象
         * 在这里就是体现的堆中的内存地址不一样，但对应的同一个常量池中的string 第一个比较时常量池中的该对象和自身比较
         * 下面两个比较则是常量池中的对象和堆中的两个对象进行比较
         */
        String poolstr = "abc";
        // 直接从字符串常量池中获取
        System.out.println(a.intern() == poolstr);// true
        System.out.println(b.intern() == poolstr);// true
        /*
         * 这里新声明并赋值了一个poolstr，值为常量池中的字符串"abc",将它和a.intern()和b.inten()比较就是和自身比较
         */
        String str = new String("a") + new String("b");
        System.out.println(str.intern() == str);// true
        /*
         * str创建了3个对象，在堆中有一个"ab"，在常量池中有一个"a"和"b" 比较str.intern()和str会得到true
         * 在jdk1.7之后，会在常量池中存一个指向堆中的那个对象的引用。
         * 调用str.intern()会在常量池中存储一个指向堆中"ab"的引用，也就是说它和堆中的对象实际是等价的，因此==时返回true
         */
        String strtwo = "ab";
        System.out.println(strtwo == str);// true
        /*
         * 常量池中已存在ab，所以会直接将strtwo指向常量池中的"ab",即堆中str对象的引用，因此相等
         */
    }
}

```
- 直接内存：不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域，java nio引入基于通道与缓冲区的I/O方式，它可以使用
native函数库直接分配堆外内存，然后通过一个存储在java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，避免了java堆和native堆来回复制数据。
- 在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：**对象头、实例数据、对齐填充**
- HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希吗、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、
偏向时间戳等；另一个部分是类型指针，即对象指向他的类元数据的指针，虚拟机通过这个指针来确定对象是哪个类的实例。
- 虚拟机新建对象时涉及到两个方面问题：对象内存的分配以及创建对象时并发的处理，采取方式如下：对象内存分配两种方式：指针碰撞、空闲列表；
解决并发问题的两种方式：对分配内存空间的动作进行同步处理、把内存分配的工作按照线程划分在不同的空间里进行，即每个线程在java堆中预先分配
一小块内存，称为本地线程缓冲区（Thread Local Allocation Buffer TLAB）。
>对象的访问定位：java程序需要通过栈上reference数据来操作堆上的具体对象。由于reference类型在java虚拟机规范中只规定一个指向对象的引用，
>并没有定义这个引用应该用何种方式去定位、访问堆上对象的具体位置，所以对象访问方式主要有两种：句柄和直接指针。
>句柄访问：java堆中划分出一块内存作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象的实例数据和类型数据各自的具体地址信息；
>直接访问：如果是直接访问方式，那么java堆中必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。
>使用句柄访问的好处就是reference中存储的是句柄地址，对象被移动或者改变，不需要改变reference中的信息，只需要修改句柄中的实例数据指针；
>使用直接访问的好处就是速度快，节省了一次指针定位的时间开销。
- -XX:+HeapDumpOnOutMemoryError：可以让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照。
- -Xms：堆最小值；-Xmx：堆最大值
- -Xoxx和-Xss设置本地方法栈大小
>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常
>如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常

# 垃圾收集器与内存分配策略
- 引用计数算法：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器加一，当引用失效时，计数器减一；任何时刻计数器为0的对象就是不再
被使用的。但是引用计数器无法解决循环引用问题
- -XX:+PrintGC 输出GC日志；-XX:+PrintGCDetails 输出GC的详细日志；-XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）；
-XX:+PrintDataStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）；- XX:+PrintHeapAtGC：在进行GC的前后打印出堆的信息
-Xloggc:../logs/gc.log 日志文件的输出路径

- 可达性分析算法：通过一系列称为称为GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots
没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。
- java语言中，可被作为GC Roots的对象包括以下几种：1.虚拟机栈（栈帧中的本地变量表）中引用的对象；2.方法区中类静态属性引用的对象；3.方法区中
常量引用的对象；4.本地方法栈中JNI（即一般说的Native方法）引用的对象。
>在jdk1.2之前，java中引用的定义是如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就称这块内存代表着一个引用。在jdk1.2之后，
>java对引用进行扩充否，分为强引用、软引用、弱引用、虚引用。
>>强引用就是指在程序代码之中普遍存在的，类似于Object obj = new Object()，这类引用，只要强引用还在，垃圾收集器永远不会回收掉被引用的对象。
>>软引用是用来描述一些还有用但并非必须的对象。对于软引用的对象，在系统中将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。
如果这次回收还是没有足够的内存，才会抛出内存溢出异常。SoftReference类实现软引用。
>>弱引用也是用来描述必须对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论
当前内存是否足够，都会回收掉只被弱引用关联的对象。WeakReference类来实现弱引用。
>>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得
一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。PhantomReference类实现虚引用

- java虚拟机中使用可达性分析算法作为GC垃圾回收的算法
>在可达性算法分析中不可达的对象，也不会立即死亡，而是至少需要经过两次标记过程：如果对象在进行可达性分析过程中发现没有和GC ROOTs相连接
>的引用链，将会进行第一次标记并进行一次筛选，筛选的条件是有无必要执行finalize()方法，当对象没有覆盖finalize方法或者finalize方法已经被
>虚拟机调用过，则认为没有必要执行，finalize方法只会被调用一次。
>如果对象有必要执行finalize方法，则会把对象放在一个名为F-Queue的队列中，并在虚拟机自动建立的一个低优先级Finalizer线程中执行，如果对象在
>finalize方法中将自己赋值为某个类变量或者对象的成员变量，那么第二次标记时它会被移除出即将回收的集合，此时对象拯救了自己，如果对象这个时间
>还没有逃脱，那么基本上确定会被回收
```java
package capter02;

/**
 *1.对象可以在被GC的时候自救
 * 2.这种自救的机会之后一次，因为一个对象的finalize方法只会被系统调用一次
 *
 */
public class FinalizeEscapeGC {
    public static FinalizeEscapeGC SAVE_HOOK = null;

    private void isAlive(){
        System.out.println("yes i am alive :)");
    }

    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("finalize is running");
        SAVE_HOOK = this;
    }

    public static void main(String[] args) throws InterruptedException {
        SAVE_HOOK = new FinalizeEscapeGC();
        //对象第一次拯救自己
        SAVE_HOOK = null;
        System.gc();
        //因为finalize的执行优先级很低
        Thread.sleep(500);
        if(SAVE_HOOK != null){
            SAVE_HOOK.isAlive();
        }else {
            System.out.println("i am dead :(");
        }
        SAVE_HOOK = null;
        System.gc();
        Thread.sleep(500);
        if(SAVE_HOOK != null){
            SAVE_HOOK.isAlive();
        }else {
            System.out.println("i am dead :(");
        }
    }
}

```

- 回收方法区（永久代）：永久代的垃圾收集主要包含废弃常量和无用类，废弃常量是指在永久代中的常量没有任何一个对象引用该常量，那么这个常量
会被清理出永久代；无用来的判定条件是：1.该类的所有的实例都已经被回收，也就是java堆中不存在该类的实例；2.加载该类的classloader已经被回收；
3.该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

-- 2019年9月6日 16:21:40 43/460
-- 2019年9月9日 08:30:35 50/460
-- 2019年9月9日 12:17:02 53/460
-- 2019年9月9日 18:13:51 56/460
-- 2019年9月10日 20:00:32 61/460
-- 2019年9月11日 11:16:48 65/460
-- 2019年9月16日 12:19:27 69/460
